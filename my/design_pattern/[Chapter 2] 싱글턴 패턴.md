# [Chapter 2] 싱글턴 패턴

싱글턴은 생성 패턴 중 가장 주목받는 패턴 중 `하나로 자원 공유를 위해 객체 생성 개수를 1개로 제한`한다.

## 일반적인 객체 생성

기존의 객체 생성 방식은 객체를 중복으로 생성할 수 있고 시스템의 자원이 허락하는 한 무제한 생성할 수 있다.

이와 같은 특징은 장점이면서 때로 단점이 된다.

### 단점1. 자원 공유

A, B 객체는 단지 생성을 위한 클래스 선언만 같을 뿐, 서로 다른 메모리에 생성된 전혀 다른 객체이기 때문에 객체의 상탯값을 공유할 수 없다.

### 단점2. 스코프 (변수 접근 영역)

전역변수로 외부 값을 공유하면 다양한 문제가 발생할 수 있고, 사이드 이팩트나 오동작이 발생할 수 있어 디버깅에 많은 어려움이 있다.

## 싱글턴 방식

싱글턴은 다른 생성 패턴과 달리 하나의 객체만 생성할 수 있도록 제한하는 패턴으로 생성된 객체는 공유되어 어디서든 접근할 수 있다.

### 싱글턴의 장점

- 공유 자원 접근
- 복수의 시스템이 하나의 자원에 접근할 때
- 유일한 객체가 필요할 때
- 값의 캐시가 필요할 때

### 전역 객체

하나의 클래스로 생성된 객체의 상탯값을 공유하려면 객체 생성을 제한해야 한다.

new 키워드를 사용할 때 서로 다른 A, B 객체가 생성되는 것이 아니라 동일한 객체 1개만 유지한다.

- 싱글턴은 전역 변수를 객체 형태로 변형해놓은 전역 객체다.
- 서로 다른 객체 값을 공유할 때나 중복되는 자원을 줄일 때 싱글턴 패턴을 적용한다.

### 싱글턴에서 객체 하나 보증하기

- new 키워드 대신 객체 생성 메서드 호출
- 내부 참조체가 있어 자신의 객체를 보관
- 내부적으로 중복 생성을 방지하는 로직(플라이웨이트 패턴)이 있음
- 싱글턴 패턴을 적용하면 클래스 상속이나 복수 객체를 생성할 수 있는 객체지향의 장점은 포기해야 함

### 접근 권한

- 일반 클래스를 싱글턴 패턴으로 변환하려면 new 키워드로 객체를 생성하지 못하게 방해
- 생성자의 접근 속성을 private으로 하여 외부에서 생성자에 접근하지 못하도록 함.

### 복제 방지

- clone 과 같은 복제 메서드도 private으로 수정

## 인스턴스 생성

### 생성 메서드

- 싱글턴 패턴에서는 내부적으로 객체를 생성할 수 있도록 특수한 메서드를 추가
- getInstance() 메서드를 정적 메서드로 만들고 객체가 없을 경우에만 새로운 객체를 생성하고, 객체가 존재할 경우에는 기존의 생성된 참조체를 반환

```java
public class SingletonConfig {
    private static SingletonConfig singletonConfig = null;
    private SingletonConfig() {
    }

    public static SingletonConfig getInstance(){
        if (singletonConfig == null) {
            singletonConfig = new SingletonConfig();
        }
        return singletonConfig;
    }
}
```

### 플라이웨이트 패턴

- 생성한 객체를 공유하는 패턴
- if 조건을 통해 참조체의 객체 존재 여부를 검사하고, 공유되는 객체가 있을 경우 참조체를 반환한다.
- 싱글턴은 플라이웨이트 패턴의 처리 로직을 추가함으로써 유일한 객체 생성을 보장받는다.

### 싱글턴과 객체지향의 원칙

- 싱글턴 패턴은 2개의 책임을 가지고 있기 때문에 SRP(단일책임원칙)을 위반한다.
    1. 클래스의 설게는 본연의 목적을 해결하기 위해 고유한 처리 로직을 갖고 있다.
    2. 중복된 객체 생성을 방지하기 위한 책임. 싱글턴은 자체적으로 참조체가 있어 참조체를 통해 중복 객체 생성을 방지하기 위한 처리 로직도 포함한다.

이와 같이 객체 지향 원칙을 반드시 적용해야 하는 것은 아니다. 예외적인 상황과 목적을 위해 위배하는 케이스도 많다.

## 정적클래스와 싱글턴의 차이점

### 정적 클래스

- 객체 생성 없이 클래스 선언을 통해 프로그램을 실행
- 정적 클래스는 객체를 생성하지 않고 소스 코드의 클래스 선언 자체를 객체로 인식하여 접근
- 정적 클래스가 선언된 하나의 자원만 사용한다는 점은 싱글턴 패턴과 유사
- 정적 클래스도 하나의 클래스만 보장하므로 동일한 효과를 볼 수 있음.

### 정적 클래스와 싱글턴의 차이점과 한계

- 싱글턴 패턴
    - 싱글턴은 메모리 자원에 할당하여 동적 객체를 만든다. (메모리 상주)
    - 선언된 정적 메서드를 통해 자체 객체를 생성하며, 생성된 객체는 정적 프로퍼티에 저장
- 정적 클래스
    - 정적 클래스는 코드가 실행되면서 고정적으로 바인딩한다. (비동적)
    - 정적 클래스는 다형성을 위한 인터페이스를 사용할 수 없음.
    - 필요한 모든 동작 기능이 정적 클래스 안에 존재해야 함.

## 싱글턴 확장

- 싱글턴 클래스는 상속받을 수 있다.
- 생성자를 private이 아니라 protected로 하여 클래스를 상속하고 확장할 수 있다.

## 종종 싱글턴을 안티 패턴이라고 분류하는 이유

### 1. 경합 조건

- 싱글턴은 하나의 객체만 생성하는 패턴이지만 특수한 환경에서 단일 객체 생성을 보장하지 못하는 경우도 있다.
- 멀티 쓰레드 환경에서 싱글턴 패턴을 사용할 때는 객체 생성이 동시에 요청되는 경우 경합성이 발생할 수 있다.
- 경합 조건은 동일한 메모리나 자원에 동시에 접근하는 것. 2개 이상의 쓰레드가 동일한 자원을 사용할 경우 충돌이 발생
- 이런 경합성 문제를 해결하기 위해 늦은 바인딩 (lazy loading?)을 사용한다. 싱글턴은 정적 호출을 통해 생성 호출 전까지는 객체를 만들지 않음. - 늦은 초기화
- 경합성과 늦은 초기화 문제를 보완하기 위해 시스템 부팅 시 필요한 싱글턴 객체를 미리 생성. 미리 공유 자원을 만듦으로써 프로그램 실행 도중 발생할 경합성 충돌을 최소화할 수 있음.
    
    ex) 스프링 컨테이너가 빈 객체를 미리 등록해 두는 것
    

### 2. 메모리 문제

- 하지만 불필요한 객체를 모두 생성하여 메모리에 상주시키는 것은 메모리 낭비임.
- 싱글턴 패턴으로 생성한 자원은 프로그램이 종료될 때까지 메모리에 상주함.

## 관련 패턴

### 팩토리 메서드와 추상 팩토리

- 팩토리 메서드 패턴과 추상 팩토리 패턴은 모두 객체를 생성하는 패턴
- 구체화된 하나의 객체만 필요한 경우 싱글턴을 함께 적용

### 빌더 패턴

- 빌더 패턴은 의존성 있는 객체를 싱글턴으로 생성할 때 결합하여 사용

### 파샤드 패턴

- 파샤드 패턴은 외부에서 객체에 접근할 수 있는 API와 같은 단일 창구.
- 싱글턴 패턴을 같이 적용하면 단일화된 접속 창구를 설계할 수 있음.

### 프로토타입 패턴

- 싱글턴을 유지하면서 동일한 객체가 추가로 필요한 경우 프로토타입 패턴을 결합하여 사용 가능

## 정리

- 싱글턴 패턴은 인기 패턴
- 클래스 내에서 하나의 객체만 사용할 경우 해당 클래스를 싱글턴 패터능로 사용 가능
- 싱글턴 생성 과정에서 다른 클래스를 의존하는 경우 의존 클래스를 먼저 처리한 후 싱글턴 객체를 생성해야 함.